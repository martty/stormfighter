struct SingleRayCastResult {
  GameObject* hitObject;
  Ogre::Vector3 hitPoint;
};

class Logger{
 public:
  void logMessage(const SString& message);
};

class Graphics {
 public:

  /// Set light used for lighting terrain
  void setTerrainLight(Ogre::Light* light);

  void renderGameObjectIntoFile(GameObject* go, SString filename, SReal width, SReal height);

  /// Returns the names of loaded Materials
  StringVector getLoadedMaterialNames();

  /// Set Camera to render on the default viewport
  void setActiveCamera(Ogre::Camera* camera);
  /// Get Camera of the default viewport
  Ogre::Camera* activeCamera() const;

  /// Get aspect ratio of default viewport
  Ogre::Real getDefaultAspectRatio();

  /// Get default viewport
  Ogre::Viewport* defaultViewport() const;

  /// Get default renderwindow (for stats)
  Ogre::RenderWindow* defaultRenderWindow() const;

  /// Get SceneManager
  Ogre::SceneManager* sceneManager() const;
  SRay activeCameraToViewportRay(SReal screenx, SReal screeny);

  SingleRayCastResult closestExactRayQuery(SRay ray);

  DebugDrawer* debugDrawer();
};



class DebugDrawer{
public:
        void setIcoSphereRecursionLevel(int recursionLevel);

        void drawLine(const Ogre::Vector3 &start, const Ogre::Vector3 &end, const Ogre::ColourValue &colour);
        void drawCircle(const Ogre::Vector3 &centre, float radius, int segmentsCount, const Ogre::ColourValue& colour, bool isFilled = false);
        void drawCylinder(const Ogre::Vector3 &centre, float radius, int segmentsCount, float height, const Ogre::ColourValue& colour, bool isFilled = false);
        void drawQuad(const Ogre::Vector3 vertices[4], const Ogre::ColourValue& colour, bool isFilled = false);
        void drawCuboid(const Ogre::Vector3 vertices[8], const Ogre::ColourValue& colour, bool isFilled = false);
        void drawSphere(const Ogre::Vector3 &centre, float radius, const Ogre::ColourValue& colour, bool isFilled = false);
        void drawTetrahedron(const Ogre::Vector3 &centre, float scale, const Ogre::ColourValue& colour, bool isFilled = false);

        bool getEnabled() { return isEnabled; }
        void setEnabled(bool _isEnabled) { isEnabled = _isEnabled; }
        void switchEnabled() { isEnabled = !isEnabled; }
};

struct CollisionData {
  Ogre::Vector3 pointOnA;
  Ogre::Vector3 pointOnB;
  Ogre::Vector3 normalOnB;

  bool stale;
  bool fresh;

  GameObject* other;
};

typedef std::map<SString, short> MaskMap;

class Physics {
 public:
  void tick(SReal deltaTime);
  /// Add a rigidbody to the simulation
  void addRigidBody(btRigidBody* rigidBody);

  void addRigidBody(btRigidBody* rigidBody, SString group, StringVector collidesWith);

  void removeRigidBody(btRigidBody* rigidBody);

  void addConstraint(Constraint* constraint);

  void addCollisionGroup(SString name);

  SingleRayCastResult closestRayCast(const Ogre::Vector3& from, const Ogre::Vector3& to);

  void setEnabled(bool enable);
  void step();
  void setDebugDraw(bool draw);
};

class Input {
 enum Axis {X, Y, Z};
 public:
  void capture();

  bool isKeyDown(const OIS::KeyCode key);
  bool isModifierDown(const OIS::Keyboard::Modifier mod);
  bool isButtonDown(const OIS::MouseButtonID button);

  int axisRelative(Axis axis);
  int axisAbsolute(Axis axis);
};

class GUI  {
 public:
  void update(double deltaTime);

  void executeJS(SString script);

  void reload();

  SString pollCommands();

  bool isInGUI(int x, int y);
};

class Hierarchy {
 public:
  void update();
  /// Searches for GO with given name in hierarchy (BFS)
  GameObject* find(SString name);

  GameObject* createGameObject(SString name);
  GameObject* createGameObject();

  void destroyGameObject(SString name);
  void destroyGameObject(GameObject* gameObject);

  GameObject* getRoot();

  /// Returns the whole hierarchy (DFS)
  SString debug();
};
