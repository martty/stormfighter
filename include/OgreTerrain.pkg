namespace Ogre
{
	class Terrain {
	public:
		typedef std::vector<Ogre::Real> Ogre::RealVector;

		/** An instance of a layer, with specific texture names
		*/
		struct LayerInstance
		{
			/// The world size of the texture to be applied in this layer
			Ogre::Real worldSize;
			/// List of texture names to import; must match with TerrainLayerDeclaration
			Ogre::StringVector textureNames;

			LayerInstance();
		};

		//typedef std::vector<Ogre::Terrain::LayerInstance> Ogre::Terrain::LayerInstanceList;
    //$renaming std::vector<Ogre::Terrain::LayerInstance> @ LayerInstanceList

    // HACK!
    class LayerInstanceList {
        void clear();
        int size() const;

        const LayerInstance& operator[](int index) const;
        LayerInstance& operator[](int index);
        void push_back(LayerInstance val);

        void resize(int size);
    }

		/// The alignment of the terrain
		enum Alignment
		{
			/// Terrain is in the X/Z plane
			ALIGN_X_Z = 0,
			/// Terrain is in the X/Y plane
			ALIGN_X_Y = 1,
			/// Terrain is in the Y/Z plane
			ALIGN_Y_Z = 2
		};

		/** Structure encapsulating import data that you may use to bootstrap
			the terrain without loading from a native data stream.
		*/
		struct ImportData
		{
			/// The alignment of the terrain
			Alignment terrainAlign;
			/// Terrain size (along one edge) in vertices; must be 2^n+1
			unsigned int terrainSize;
			/** Maximum batch size (along one edge) in vertices; must be 2^n+1 and <= 65
			@remarks
				The terrain will be divided into hierarchical tiles, and this is the maximum
				size of one tile in vertices (at any LOD).
			*/
			unsigned int maxBatchSize;
			/** Minimum batch size (along one edge) in vertices; must be 2^n+1.
			@remarks
			The terrain will be divided into tiles, and this is the minimum
			size of one tile in vertices (at any LOD). Adjacent tiles will be
			collected together into one batch to drop LOD levels once they are individually at this minimum,
			so setting this value higher means greater batching at the expense
			of making adjacent tiles use a common LOD.
			Once the entire terrain is collected together into one batch this
			effectively sets the minimum LOD.
			*/
			unsigned int minBatchSize;

			/** Position of the terrain.
			@remarks
				Represents the position of the centre of the terrain.
			*/
			Vector3 pos;

			/** The world size of the terrain. */
			Ogre::Real worldSize;

			/** Optional heightmap providing the initial heights for the terrain.
			@remarks
				If supplied, should ideally be terrainSize * terrainSize, but if
				it isn't it will be resized.
			*/
			Ogre::Image* inputImage;

			/** Optional list of terrainSize * terrainSize floats defining the terrain.
				The list of floats wil be interpreted such that the first row
				in the array equates to the bottom row of vertices.
			*/
			//float* inputFloat; - unsupported by tolua

			/** If neither inputOgre::Image or inputFloat are supplied, the constant
				height at which the initial terrain should be created (flat).
			*/
			float constantHeight;

			/** Whether this structure should 'own' the input data (inputImage and
				inputFloat), and therefore delete it on destruction.
				The default is false so you have to manage your own memory. If you
				set it to true, then you must have allocated the memory through
				OGRE_NEW (for Ogre::Image) and OGRE_ALLOC_T (for inputFloat), the latter
				with the category MEMCATEGORY_GEOMETRY.
			*/
			bool deleteInputData;

			/// How to scale the input values provided (if any)
			Ogre::Real inputScale;
			/// How to bias the input values provided (if any)
			Ogre::Real inputBias;

			/** Definition of the contents of each layer (required).
			Most likely,  you will pull a declaration from a TerrainMaterialGenerator
			of your choice.
			*/
			Ogre::TerrainLayerDeclaration layerDeclaration;
			/** List of layer structures, one for each layer required.
				Can be empty or underfilled if required, list will be padded with
				blank textures.
			*/
			Ogre::Terrain::LayerInstanceList layerList;

			ImportData();

			ImportData(const ImportData& rhs);

			ImportData& operator=(const ImportData& rhs);

			/// Delete any input data if this struct is set to do so
			void destroy();

			~ImportData();

		};

		/// Neighbour index enumeration - indexed anticlockwise from East like angles
		enum NeighbourIndex
		{
			NEIGHBOUR_EAST = 0,
			NEIGHBOUR_NORTHEAST = 1,
			NEIGHBOUR_NORTH = 2,
			NEIGHBOUR_NORTHWEST = 3,
			NEIGHBOUR_WEST = 4,
			NEIGHBOUR_SOUTHWEST = 5,
			NEIGHBOUR_SOUTH = 6,
			NEIGHBOUR_SOUTHEAST = 7,

			NEIGHBOUR_COUNT = 8
		};
		/// Enumeration of relative spaces that you might want to use to address the terrain
		enum Space
		{
			/// Simple global world space, axes and positions are all in world space
			WORLD_SPACE = 0,
			/// As world space, but positions are relative to the terrain world position
			LOCAL_SPACE = 1,
			/** x & y are parametric values on the terrain from 0 to 1, with the
			origin at the bottom left. z is the world space height at that point.
			*/
			TERRAIN_SPACE = 2,
			/** x & y are integer points on the terrain from 0 to size-1, with the
			origin at the bottom left. z is the world space height at that point.
			*/
			POINT_SPACE = 3
		};

		/** Convert a position from one space to another with respect to this terrain.
		@param inSpace The space that inPos is expressed as
		@param inPos The incoming position
		@param outSpace The space which outPos should be expressed as
		@param outPos The output position to be populated
		*/
		void convertPosition(Space inSpace, const Vector3& inPos, Space outSpace, Vector3& outPos) const;
		/** Convert a position from one space to another with respect to this terrain.
		@param inSpace The space that inPos is expressed as
		@param inPos The incoming position
		@param outSpace The space which outPos should be expressed as
		@returns The output position
		*/
		Vector3 convertPosition(Space inSpace, const Vector3& inPos, Space outSpace) const;
		/** Convert a direction from one space to another with respect to this terrain.
		@param inSpace The space that inDir is expressed as
		@param inDir The incoming direction
		@param outSpace The space which outDir should be expressed as
		@param outDir The output direction to be populated
		*/
		void convertDirection(Space inSpace, const Vector3& inDir, Space outSpace, Vector3& outDir) const;
		/** Convert a direction from one space to another with respect to this terrain.
		@param inSpace The space that inDir is expressed as
		@param inDir The incoming direction
		@param outSpace The space which outDir should be expressed as
		@returns The output direction
		*/
		Vector3 convertDirection(Space inSpace, const Vector3& inDir, Space outSpace) const;

		/** Save terrain data in native form to a standalone file
		@param filename The name of the file to save to. If this is a filename with
			no path elements, then it is saved in the first writeable location
			available in the resource group you have chosen to use for this
			terrain. If the filename includes path specifiers then it is saved
			directly instead (but note that it may not be reloadable via the
			resource system if the location is not on the path).
		*/
		void save(const Ogre::String& filename);

		/** Prepare the terrain from a standalone file.
		@note
		This is safe to do in a background thread as it creates no GPU resources.
		It reads data from a native terrain data chunk. For more advanced uses,
		such as loading from a shared file, use the StreamSerialiser form.
		*/
		bool prepare(const Ogre::String& filename);

		/** Prepare the terrain from some import data rather than loading from
			native data.
		@remarks
			This method may be called in a background thread.
		*/
		bool prepare(const ImportData& importData);

		/** Prepare and load the terrain in one simple call from a standalone file.
		@note
			This method must be called from the primary render thread. To load data
			in a background thread, use the prepare() method.
		*/
		void load(const Ogre::String& filename);

		/** Load the terrain based on the data already populated via prepare methods.
		@remarks
			This method must be called in the main render thread.
		*/
		void load();

		/** Return whether the terrain is loaded.
		@remarks
			Should only be called from the render thread really, since this is
			where the loaded state changes.
		*/
		bool isLoaded() const;

		/** Returns whether this terrain has been modified since it was first loaded / defined.
		@remarks
			This flag is reset on save().
		*/
		bool isModified() const;


		/** Returns whether terrain heights have been modified since the terrain was first loaded / defined.
		@remarks
		This flag is reset on save().
		*/
		bool isHeightDataModified() const;


		/** Unload the terrain and free GPU resources.
		@remarks
			This method must be called in the main render thread.
		*/
		void unload();

		/** Free CPU resources created during prepare methods.
		@remarks
			This is safe to do in a background thread after calling unload().
		*/
		void unprepare();


		/** Get a pointer to all the height data for this terrain.
		@remarks
			The height data is in world coordinates, relative to the position
			of the terrain.
		@par
			This pointer is not const, so you can update the height data if you
			wish. However, changes will not be propagated until you call
			Terrain::dirty or Terrain::dirtyRect.
		*/
		float* getHeightData() const;

		/** Get a pointer to the height data for a given point.
		*/
		float* getHeightData(long x, long y) const;

		/** Get the height data for a given terrain point.
		@param x, y Discrete coordinates in terrain vertices, values from 0 to size-1,
			left/right bottom/top
		*/
		float getHeightAtPoint(long x, long y) const;

		/** Set the height data for a given terrain point.
		@note this doesn't take effect until you call update()
		@param x, y Discrete coordinates in terrain vertices, values from 0 to size-1,
		left/right bottom/top
		@param h The new height
		*/
		void setHeightAtPoint(long x, long y, float h);

		/** Get the height data for a given terrain position.
		@param x, y Position in terrain space, values from 0 to 1 left/right bottom/top
		*/
		float getHeightAtTerrainPosition(Ogre::Real x, Ogre::Real y);

		/** Get the height data for a given world position (projecting the point
			down on to the terrain).
		@param x, y,z Position in world space. Positions will be clamped to the edge
			of the terrain
		*/
		float getHeightAtWorldPosition(Ogre::Real x, Ogre::Real y, Ogre::Real z);

		/** Get the height data for a given world position (projecting the point
		down on to the terrain).
		@param pos Position in world space. Positions will be clamped to the edge
		of the terrain
		*/
		float getHeightAtWorldPosition(const Vector3& pos);

		/** Get a pointer to all the delta data for this terrain.
		@remarks
			The delta data is a measure at a given vertex of by how much vertically
			a vertex will have to move to reach the point at which it will be
			removed in the next lower LOD.
		*/
		const float* getDeltaData();

		/** Get a pointer to the delta data for a given point.
		*/
		const float* getDeltaData(long x, long y);

		/** Get a Vector3 of the world-space point on the terrain, aligned as per
			options.
		@note This point is relative to Terrain::getPosition
		*/
		void getPoint(long x, long y, Vector3* outpos);

		/** Get a Vector3 of the world-space point on the terrain, aligned as per
		options. Cascades into neighbours if out of bounds.
		@note This point is relative to Terrain::getPosition - neighbours are
			adjusted to be relative to this tile
		*/
		void getPointFromSelfOrNeighbour(long x, long y, Vector3* outpos);

		/** Get a Vector3 of the world-space point on the terrain, supplying the
			height data manually (can be more optimal).
		@note This point is relative to Terrain::getPosition
		*/
		void getPoint(long x, long y, float height, Vector3* outpos);
		/** Translate a vector from world space to local terrain space based on the alignment options.
		@param inVec The vector in basis space, where x/y represents the
		terrain plane and z represents the up vector
		*/
		void getTerrainVector(const Vector3& inVec, Vector3* outVec);
		/** Translate a vector from world space to local terrain space based on a specified alignment.
		@param inVec The vector in basis space, where x/y represents the
		terrain plane and z represents the up vector
		*/
		void getTerrainVectorAlign(const Vector3& inVec, Alignment align, Vector3* outVec);

		/** Translate a vector from world space to local terrain space based on the alignment options.
		@param x, y, z The vector in basis space, where x/y represents the
		terrain plane and z represents the up vector
		*/
		void getTerrainVector(Ogre::Real x, Ogre::Real y, Ogre::Real z, Vector3* outVec);
		/** Translate a vector from world space to local terrain space based on a specified alignment.
		@param x, y, z The vector in world space, where x/y represents the
		terrain plane and z represents the up vector
		*/
		void getTerrainVectorAlign(Ogre::Real x, Ogre::Real y, Ogre::Real z, Alignment align, Vector3* outVec);

		/** Translate a vector into world space based on the alignment options.
		@param inVec The vector in basis space, where x/y represents the
		terrain plane and z represents the up vector
		*/
		void getVector(const Vector3& inVec, Vector3* outVec);
		/** Translate a vector into world space based on a specified alignment.
		@param inVec The vector in basis space, where x/y represents the
		terrain plane and z represents the up vector
		*/
		void getVectorAlign(const Vector3& inVec, Alignment align, Vector3* outVec);

		/** Translate a vector into world space based on the alignment options.
		@param x, y, z The vector in basis space, where x/y represents the
		terrain plane and z represents the up vector
		*/
		void getVector(Ogre::Real x, Ogre::Real y, Ogre::Real z, Vector3* outVec);
		/** Translate a vector into world space based on a specified alignment.
		@param x, y, z The vector in basis space, where x/y represents the
		terrain plane and z represents the up vector
		*/
		void getVectorAlign(Ogre::Real x, Ogre::Real y, Ogre::Real z, Alignment align, Vector3* outVec);


		/** Convert a position from terrain basis space to world space.
		@param TSpos Terrain space position, where (0,0) is the bottom-left of the
			terrain, and (1,1) is the top-right. The Z coordinate is in absolute
			height units.
		@note This position is relative to Terrain::getPosition
		@param outWSpos World space output position (setup according to current alignment).
		*/
		void getPosition(const Vector3& TSpos, Vector3* outWSpos);
		/** Convert a position from terrain basis space to world space.
		@param x,y,z Terrain space position, where (0,0) is the bottom-left of the
		terrain, and (1,1) is the top-right. The Z coordinate is in absolute
		height units.
		@note This position is relative to Terrain::getPosition
		@param outWSpos World space output position (setup according to current alignment).
		*/
		void getPosition(Ogre::Real x, Ogre::Real y, Ogre::Real z, Vector3* outWSpos);

		/** Convert a position from world space to terrain basis space.
		@param WSpos World space position (setup according to current alignment).
		@param outTSpos Terrain space output position, where (0,0) is the bottom-left of the
		terrain, and (1,1) is the top-right. The Z coordinate is in absolute
		height units.
		*/
		void getTerrainPosition(const Vector3& WSpos, Vector3* outTSpos);
		/** Convert a position from world space to terrain basis space.
		@param x,y,z World space position (setup according to current alignment).
		@param outTSpos Terrain space output position, where (0,0) is the bottom-left of the
		terrain, and (1,1) is the top-right. The Z coordinate is in absolute
		height units.
		*/
		void getTerrainPosition(Ogre::Real x, Ogre::Real y, Ogre::Real z, Vector3* outTSpos);
		/** Convert a position from terrain basis space to world space based on a specified alignment.
		@param TSpos Terrain space position, where (0,0) is the bottom-left of the
			terrain, and (1,1) is the top-right. The Z coordinate is in absolute
			height units.
		@param outWSpos World space output position (setup according to alignment).
		*/
		void getPositionAlign(const Vector3& TSpos, Alignment align, Vector3* outWSpos);
		/** Convert a position from terrain basis space to world space based on a specified alignment.
		@param x,y,z Terrain space position, where (0,0) is the bottom-left of the
		terrain, and (1,1) is the top-right. The Z coordinate is in absolute
		height units.
		@param outWSpos World space output position (setup according to alignment).
		*/
		void getPositionAlign(Ogre::Real x, Ogre::Real y, Ogre::Real z, Alignment align, Vector3* outWSpos);

		/** Convert a position from world space to terrain basis space based on a specified alignment.
		@param WSpos World space position (setup according to alignment).
		@param outTSpos Terrain space output position, where (0,0) is the bottom-left of the
		terrain, and (1,1) is the top-right. The Z coordinate is in absolute
		height units.
		*/
		void getTerrainPositionAlign(const Vector3& WSpos, Alignment align, Vector3* outTSpos);
		/** Convert a position from world space to terrain basis space based on a specified alignment.
		@param x,y,z World space position (setup according to alignment).
		@param outTSpos Terrain space output position, where (0,0) is the bottom-left of the
		terrain, and (1,1) is the top-right. The Z coordinate is in absolute
		height units.
		*/
		void getTerrainPositionAlign(Ogre::Real x, Ogre::Real y, Ogre::Real z, Alignment align, Vector3* outTSpos);


		/// Get the alignment of the terrain
		Alignment getAlignment() const;
		/// Get the size of the terrain in vertices along one side
		unsigned int getSize() const;
		/// Get the maximum size in vertices along one side of a batch
		unsigned int getMaxBatchSize() const;
		/// Get the minimum size in vertices along one side of a batch
		unsigned int getMinBatchSize() const;
		/// Get the size of the terrain in world units
		Ogre::Real getWorldSize() const;

		/** Get the number of layers in this terrain. */
		unsigned int getLayerCount() const;
		/** Get the declaration which describes the layers in this terrain. */
		const Ogre::TerrainLayerDeclaration& getLayerDeclaration() const;

		/** Add a new layer to this terrain.
		@param worldSize The size of the texture in this layer in world units. Default
		to zero to use the default
		@param textureNames A list of textures to assign to the samplers in this
			layer. Leave blank to provide these later.
		*/
		void addLayer(Ogre::Real worldSize = 0, const Ogre::StringVector* textureNames = 0);

		/** Add a new layer to this terrain at a specific index.
		@param index The index at which to insert this layer (existing layers are shifted forwards)
		@param worldSize The size of the texture in this layer in world units. Default
		to zero to use the default
		@param textureNames A list of textures to assign to the samplers in this
			layer. Leave blank to provide these later.
		*/
		void addLayer(unsigned int index, Ogre::Real worldSize = 0, const Ogre::StringVector* textureNames = 0);

		/** Remove a layer from the terrain.
		*/
		void removeLayer(unsigned int index);

		/** Replace an existing terrain layer, optionally preserving all other layer blend maps
		@param index The 0 based index of the terrain layer to replace
		@param keepBlends True to keep using the existing blend maps.  False to reset the blend map for the layer.
		Irrelevant if index == 0
		@param worldSize The size of the texture in this layer in world units. Default
		to zero to use the default
		@param textureNames A list of textures to assign to the samplers in this
			layer. Leave blank to provide these later.
		*/
        void replaceLayer(unsigned int index, bool keepBlends, Ogre::Real worldSize = 0, const Ogre::StringVector* textureNames = 0);

		/** Get the maximum number of layers supported with the current options.
		@note When you change the options requested, this value can change.
		*/
		unsigned int getMaxLayers() const;

		/** How large an area in world space the texture in a terrain layer covers
		before repeating.
		@param index The layer index.
		*/
		Ogre::Real getLayerWorldSize(unsigned int index) const;
		/** How large an area in world space the texture in a terrain layer covers
		before repeating.
		@param index The layer index.
		@param size The world size of the texture before repeating
		*/
		void setLayerWorldSize(unsigned int index, Ogre::Real size);

		/** Get the layer UV multiplier.
		@remarks
			This is derived from the texture world size. The base UVs in the
			terrain vary from 0 to 1 and this multiplier is used (in a fixed-function
			texture coord scaling or a shader parameter) to translate it to the
			final value.
		@param index The layer index.
		*/
		Ogre::Real getLayerUVMultiplier(unsigned int index) const;

		/** Get the name of the texture bound to a given index within a given layer.
		See the LayerDeclaration for a list of sampelrs within a layer.
		@param layerIndex The layer index.
		@param samplerIndex The sampler index within a layer
		*/
		const Ogre::String& getLayerTextureName(unsigned int layerIndex, unsigned int samplerIndex) const;
		/** Set the name of the texture bound to a given index within a given layer.
		See the LayerDeclaration for a list of sampelrs within a layer.
		@param index The layer index.
		@param size The world size of the texture before repeating
		@param textureName The name of the texture to use
		*/
		void setLayerTextureName(unsigned int layerIndex, unsigned int samplerIndex, const Ogre::String& textureName);

		/** Get the requested size of the blend maps used to blend between layers
			for this terrain.
			Note that where hardware limits this, the actual blend maps may be lower
			resolution. This option is derived from TerrainGlobalOptions when the
			terrain is created.
		*/
		unsigned int getLayerBlendMapSize() const;

		/** Get the requested size of lightmap for this terrain.
		Note that where hardware limits this, the actual lightmap may be lower
		resolution. This option is derived from TerrainGlobalOptions when the
		terrain is created.
		*/
		unsigned int getLightmapSize() const;

		/// Get access to the lightmap, if enabled (as requested by the material generator)
		const Ogre::TexturePtr& getLightmap() const;

		/** Get the requested size of composite map for this terrain.
		Note that where hardware limits this, the actual texture may be lower
		resolution. This option is derived from TerrainGlobalOptions when the
		terrain is created.
		*/
		unsigned int getCompositeMapSize() const;

		/// Get access to the composite map, if enabled (as requested by the material generator)
		const Ogre::TexturePtr& getCompositeMap() const;

		/// Get the world position of the terrain centre
		const Vector3& getPosition() const;
		/// Set the position of the terrain centre in world coordinates
		void setPosition(const Vector3& pos);

		/** Mark the entire terrain as dirty.
		By marking a section of the terrain as dirty, you are stating that you have
		changed the height data within this rectangle. This rectangle will be merged with
		any existing outstanding changes. To finalise the changes, you must
		call update(), updateGeometry(), or updateDerivedData().
		*/
		void dirty();

		/** Mark a region of the terrain as dirty.
		By marking a section of the terrain as dirty, you are stating that you have
		changed the height data within this rectangle. This rectangle will be merged with
		any existing outstanding changes. To finalise the changes, you must
		call update(), updateGeometry(), or updateDerivedData().
		@param rect A rectangle expressed in vertices describing the dirty region;
			left < right, top < bottom, left & top are inclusive, right & bottom exclusive
		*/
		void dirtyRect(const Ogre::Rect& rect);

		/** Mark a region of the lightmap as dirty.
		@remarks
			You only need to call this if you need to tell the terrain to update
			the lightmap data for some reason other than the terrain geometry
			has changed. Changing terrain geometry automatically dirties the
			correct lightmap areas.
		@note
			The lightmap won't actually be updated until update() or updateDerivedData()
			is called.
		*/
		void dirtyLightmapRect(const Ogre::Rect& rect);

		/** Mark a the entire lightmap as dirty.
		@remarks
			You only need to call this if you need to tell the terrain to update
			the lightmap data for some reason other than the terrain geometry
			has changed. Changing terrain geometry automatically dirties the
			correct lightmap areas.
		@note
			The lightmap won't actually be updated until update() or updateDerivedData()
			is called.
		*/
		void dirtyLightmap();

		/** Trigger the update process for the terrain.
		@remarks
			Updating the terrain will process any dirty sections of the terrain.
			This may affect many things:
			<ol><li>The terrain geometry</li>
			<li>The terrain error metrics which determine LOD transitions</li>
			<li>The terrain normal map, if present</li>
			<li>The terrain lighting map, if present</li>
			<li>The terrain composite map, if present</li>
			</ol>
			If threading is enabled, only item 1 (the geometry) will be updated
			synchronously, ie will be fully up to date when this method returns.
			The other elements are more expensive to compute, and will be queued
			for processing in a background thread, in the order shown above. As these
			updates complete, the effects will be shown.

			You can also separate the timing of updating the geometry, LOD and the lighting
			information if you want, by calling updateGeometry() and
			updateDerivedData() separately.
			@param synchronous If true, all updates will happen immediately and not
			in a separate thread.
		*/
		void update(bool synchronous = false);

		/** Performs an update on the terrain geometry based on the dirty region.
		@remarks
			Terrain geometry will be updated when this method returns.
		*/
		void updateGeometry();

		// Used as a type mask for updateDerivedData
		static const unsigned int DERIVED_DATA_DELTAS;
		static const unsigned int DERIVED_DATA_NORMALS;
		static const unsigned int DERIVED_DATA_LIGHTMAP;
		static const unsigned int DERIVED_DATA_ALL;

		/** Updates derived data for the terrain (LOD, lighting) to reflect changed height data, in a separate
		thread if threading is enabled (OGRE_THREAD_SUPPORT).
		If threading is enabled, on return from this method the derived
		data will not necessarily be updated immediately, the calculation
		may be done in the background. Only one update will run in the background
		at once. This derived data can typically survive being out of sync for a
		few frames which is why it is not done synchronously
		@param synchronous If true, the update will happen immediately and not
			in a separate thread.
		@param typeMask Mask indicating the types of data we should generate
		*/
		void updateDerivedData(bool synchronous = false, unsigned int typeMask = 0xFF);

		/** Performs an update on the terrain composite map based on its dirty region.
		@remarks
			Rather than calling this directly, call updateDerivedData, which will
			also call it after the other derived data has been updated (there is
			no point updating the composite map until lighting has been updated).
			However the blend maps may call this directly when only the blending
			information has been updated.
		*/
		void updateCompositeMap();

		/** Performs an update on the terrain composite map based on its dirty region,
			but only at a maximum frequency.
		@remarks
		Rather than calling this directly, call updateDerivedData, which will
		also call it after the other derived data has been updated (there is
		no point updating the composite map until lighting has been updated).
		However the blend maps may call this directly when only the blending
		information has been updated.
		@note
		This method will log the request for an update, but won't do it just yet
		unless there are no further requests in the next 'delay' seconds. This means
		you can call it all the time but only pick up changes in quiet times.
		*/
		void updateCompositeMapWithDelay(Ogre::Real delay = 2);


		/** The default size of 'skirts' used to hide terrain cracks
			(default 10, set for new Terrain using TerrainGlobalOptions)
		*/
		Ogre::Real getSkirtSize() const;

		/// Get the total number of LOD levels in the terrain
		unsigned int getNumLodLevels() const;

		/// Get the number of LOD levels in a leaf of the terrain quadtree
		unsigned int getNumLodLevelsPerLeaf() const;

		/** Calculate (or recalculate) the delta values of heights between a vertex
			in its recorded position, and the place it will end up in the LOD
			in which it is removed.
		@param rect Rectangle describing the area in which heights have altered
		@returns A Rectangle describing the area which was updated (may be wider
			than the input rectangle)
		*/
		Ogre::Rect calculateHeightDeltas(const Ogre::Rect& rect);

		/** Finalise the height deltas.
		Calculated height deltas are kept in a separate calculation field to make
		them safe to perform in a background thread. This call promotes those
		calculations to the runtime values, and must be called in the main thread.
		@param rect Rectangle describing the area to finalise
		@param cpuData When updating vertex data, update the CPU copy (background)
		*/
		void finaliseHeightDeltas(const Ogre::Rect& rect, bool cpuData);

		/** Calculate (or recalculate) the normals on the terrain
		@param rect Rectangle describing the area of heights that were changed
		@param outFinalRect Output rectangle describing the area updated
		@returns Pointer to a PixelBox full of normals (caller responsible for deletion)
		*/
		Ogre::PixelBox* calculateNormals(const Ogre::Rect& rect, Ogre::Rect& outFinalRect);

		/** Finalise the normals.
		Calculated normals are kept in a separate calculation area to make
		them safe to perform in a background thread. This call promotes those
		calculations to the runtime values, and must be called in the main thread.
		@param rect Rectangle describing the area to finalise
		@param normalsBox Pointer to a PixelBox full of normals
		*/
		void finaliseNormals(const Ogre::Rect& rect, Ogre::PixelBox* normalsBox);

		/** Calculate (or recalculate) the terrain lightmap
		@param rect Rectangle describing the area of heights that were changed
		@param extraTargetRect Rectangle describing a target area of the terrain that
			needs to be calculated additionally (e.g. from a neighbour)
		@param outFinalRect Output rectangle describing the area updated in the lightmap
		@returns Pointer to a PixelBox full of lighting data (caller responsible for deletion)
		*/
		Ogre::PixelBox* calculateLightmap(const Ogre::Rect& rect, const Ogre::Rect& extraTargetRect, Ogre::Rect& outFinalRect);

		/** Finalise the lightmap.
		Calculating lightmaps is kept in a separate calculation area to make
		it safe to perform in a background thread. This call promotes those
		calculations to the runtime values, and must be called in the main thread.
		@param rect Rectangle describing the area to finalise
		@param normalsBox Pointer to a PixelBox full of normals
		*/
		void finaliseLightmap(const Ogre::Rect& rect, Ogre::PixelBox* lightmapBox);

		/** Gets the resolution of the entire terrain (down one edge) at a
			given LOD level.
		*/
		unsigned int getResolutionAtLod(unsigned int lodLevel);

		/** Test for intersection of a given ray with the terrain. If the ray hits
		 the terrain, the point of intersection is returned.
		 @param ray The ray to test for intersection
		 @param cascadeToNeighbours Whether the ray will be projected onto neighbours if
			no intersection is found
		 @param distanceLimit The distance from the ray origin at which we will stop looking,
			0 indicates no limit
		 @return A pair which contains whether the ray hit the terrain and, if so, where.
		 @remarks This can be called from any thread as long as no parallel write to
		 the heightmap data occurs.
		 */
		std::pair<bool, Vector3> rayIntersects(const Ogre::Ray& ray,
			bool cascadeToNeighbours = false, Ogre::Real distanceLimit = 0); //const;

		/// Get the AABB (local coords) of the entire terrain
		const Ogre::AxisAlignedBox& getAABB() const;
		/// Get the AABB (world coords) of the entire terrain
		Ogre::AxisAlignedBox getWorldAABB() const;
		/// Get the minimum height of the terrain
		Ogre::Real getMinHeight() const;
		/// Get the maximum height of the terrain
		Ogre::Real getMaxHeight() const;
		/// Get the bounding radius of the entire terrain
		Ogre::Real getBoundingRadius() const;

		/// Get the material being used for the terrain
		const Ogre::MaterialPtr& getMaterial() const;
		/// Internal getting of material
		const Ogre::MaterialPtr& _getMaterial() const;
		/// Get the material being used for the terrain composite map
		const Ogre::MaterialPtr& getCompositeMapMaterial() const;
		/// Internal getting of material  for the terrain composite map
		const Ogre::MaterialPtr& _getCompositeMapMaterial() const;
		/// Get the name of the material being used for the terrain
		const Ogre::String& getMaterialName() const;

		/// Overridden from Ogre::SceneManager::Listener
		void preFindVisibleObjects(Ogre::SceneManager* source,
			Ogre::SceneManager::IlluminationRenderStage irs, Ogre::Viewport* v);
		/// Overridden from Ogre::SceneManager::Listener
		void sceneManagerDestroyed(Ogre::SceneManager* source);

		/// Get the render queue group that this terrain will be rendered into
		unsigned int getRenderQueueGroup(void) const;
		/** Set the render queue group that this terrain will be rendered into.
		@remarks The default is specified in TerrainGlobalOptions
		*/
		void setRenderQueueGroup(unsigned int grp);

		/// Get the visibility flags for this terrain.
		unsigned int getVisibilityFlags(void) const;
		/** Set the visibility flags for this terrain.
		@remarks The default is specified in TerrainGlobalOptions
		*/
		void setVisibilityFlags(unsigned int flags);

		/// Get the query flags for this terrain.
		unsigned int getQueryFlags(void) const;
		/** Set the query flags for this terrain.
		@remarks The default is specified in TerrainGlobalOptions
		*/
		void setQueryFlags(unsigned int flags);

		/** As setQueryFlags, except the flags passed as parameters are appended to the existing flags on this object. */
		void addQueryFlags(unsigned int flags);

		/* As setQueryFlags, except the flags passed as parameters are removed from the existing flags on this object. */
		void removeQueryFlags(unsigned int flags);


		/** Retrieve the layer blending map for a given layer, which may
			be used to edit the blending information for that layer.
		@note
			You can only do this after the terrain has been loaded. You may
			edit the content of the blend layer in another thread, but you
			may only upload it in the main render thread.
		@param layerIndex The layer index, which should be 1 or higher (since
			the bottom layer has no blending).
		@returns Pointer to the TerrainLayerBlendMap requested. The caller must
			not delete this instance, use freeTemporaryResources if you want
			to save the memory after completing your editing.
		*/
		Ogre::TerrainLayerBlendMap* getLayerBlendMap(unsigned int layerIndex);

		/** Get the index of the blend texture that a given layer uses.
		@param layerIndex The layer index, must be >= 1 and less than the number
			of layers
		@returns The index of the shared blend texture
		*/
		unsigned int getBlendTextureIndex(unsigned int layerIndex) const;

		/// Get the number of blend textures in use
		unsigned int getBlendTextureCount() const;
		/// Get the number of blend textures needed for a given number of layers
		unsigned int getBlendTextureCount(unsigned int numLayers) const;


		/** Get the name of the packed blend texture at a specific index.
		@param textureIndex This is the blend texture index, not the layer index
			(multiple layers will share a blend texture)
		*/
		const Ogre::String& getBlendTextureName(unsigned int textureIndex) const;

		/** Set whether a global colour map is enabled.
		@remarks
			A global colour map can add variation to your terrain and reduce the
			perceived tiling effect you might get in areas of continuous lighting
			and the same texture.
			The global colour map is only used when the material generator chooses
			to use it.
		@note You must only call this from the main render thread
		@param enabled Whether the global colour map is enabled or not
		@param size The resolution of the colour map. A value of zero means 'no change'
			and the default is set in TerrainGlobalOptions.
		*/
		void setGlobalColourMapEnabled(bool enabled, unsigned int size = 0);
		/// Get whether a global colour map is enabled on this terrain
		bool getGlobalColourMapEnabled() const;
		/// Get the size of the global colour map (if used)
		unsigned int getGlobalColourMapSize() const;
		/// Get access to the global colour map, if enabled
		const Ogre::TexturePtr& getGlobalColourMap() const;

		/** Widen a rectangular area of terrain to take into account an extrusion vector.
		@param vec A vector in world space
		@param inRect Input rectangle
		@param inRect Output rectangle
		*/
		void widenRectByVector(const Vector3& vec, const Ogre::Rect& inRect, Ogre::Rect& outRect);

		/** Widen a rectangular area of terrain to take into account an extrusion vector,
			but specify the min / max heights to extrude manually.
		@param vec A vector in world space
		@param inRect Input rectangle
		@param minHeight, maxHeight The extents of the height to extrude
		@param inRect Output rectangle
		*/
		void widenRectByVector(const Vector3& vec, const Ogre::Rect& inRect,
			Ogre::Real minHeight, Ogre::Real maxHeight, Ogre::Rect& outRect);

		/** Free as many resources as possible for optimal run-time memory use.
		@remarks
			This class keeps some temporary storage around in order to make
			certain actions (such as editing) possible more quickly. Calling this
			method will cause as many of those resources as possible to be
			freed. You might want to do this for example when you are finished
			editing a particular terrain and want to have optimal runtime
			efficiency.
		*/
		void freeTemporaryResources();

		/** Get a blend texture with a given index.
		@param index The blend texture index (note: not layer index; derive
		the texture index from getLayerBlendTextureIndex)
		*/
		const Ogre::TexturePtr& getLayerBlendTexture(unsigned int index);

		/** Get the texture index and colour channel of the blend information for
			a given layer.
		@param layerIndex The index of the layer (1 or higher, layer 0 has no blend data)
		@returns A pair in which the first value is the texture index, and the
			second value is the colour channel (RGBA)
		*/
		std::pair<unsigned int,unsigned int> getLayerBlendTextureIndex(unsigned int layerIndex);

		/// Utility method, get the first LOD Level at which this vertex is no longer included
		unsigned int getLODLevelWhenVertexEliminated(long x, long y);
		/// Utility method, get the first LOD Level at which this vertex is no longer included
		unsigned int getLODLevelWhenVertexEliminated(long rowOrColulmn);

		/// Get the (global) normal map texture
		Ogre::TexturePtr getTerrainNormalMap() const;

		/** Retrieve the terrain's neighbour, or null if not present.
		@remarks
			Terrains only know about their neighbours if they are notified via
			setNeighbour. This information is not saved with the terrain since every
			tile must be able to be independent.
		@param index The index of the neighbour
		*/
		Terrain* getNeighbour(NeighbourIndex index);

		/** Set a terrain's neighbour, or null to detach one.
		@remarks
			This information is not saved with the terrain since every
			tile must be able to be independent. However if modifications are
			made to a tile which can affect its neighbours, while connected the
			changes will be propagated.
		@param index The index of the neighbour
		@param neighbour The terrain instance to become the neighbour, or null to reset.
		@param recalculate If true, this terrain instance will recalculate elements
			that could be affected by the connection of this tile (e.g. matching
			heights, calcaulting normals, calculating shadows crossing the boundary).
			If false, this terrain's state is assumed to be up to date already
			(e.g. was calculated with this tile present before and the state saved).
		@param notifyOther Whether the neighbour should also be notified (recommended
			to leave this at the default so relationships are up to date before
			background updates are triggered)
		*/
		void setNeighbour(NeighbourIndex index, Terrain* neighbour, bool recalculate = false, bool notifyOther = true);

		/** Get the opposite neighbour relationship (useful for finding the
			neighbour index from the perspective of the tile the other side of the
			boundary).
		*/
		static NeighbourIndex getOppositeNeighbour(NeighbourIndex index);

		/** Get the neighbour enum for a given offset in a grid (signed).
		*/
		static NeighbourIndex getNeighbourIndex(long offsetx, long offsety);

		/** Tell this instance to notify all neighbours that will be affected
			by a height change that has taken place.
		@remarks
			This method will determine which neighbours need notification and call
			their neighbourModified method. It is called automatically by
			updateGeometry().
		*/
		void notifyNeighbours();

		/** Notify that a neighbour has just finished updating and that this
			change affects this tile.
		@param index The neighbour index (from this tile's perspective)
		@param edgerect The area at the edge of this tile that needs height / normal
			recalculation (may be null)
		@param shadowrect The area on this tile where shadows need recalculating (may be null)
		*/
		void neighbourModified(NeighbourIndex index, const Ogre::Rect& edgerect, const Ogre::Rect& shadowrect);

		/** Utility method to pick a neighbour based on a ray.
		@param ray The ray in world space
		@param distanceLimit Limit beyond which we want to ignore neighbours (0 for infinite)
		@returns The first neighbour along this ray, or null
		*/
		Terrain* raySelectNeighbour(const Ray& ray, Ogre::Real distanceLimit = 0);


		/** Query whether a derived data update is in progress or not. */
		bool isDerivedDataUpdateInProgress() const;


		/// Utility method to convert axes from world space to terrain space (xy terrain, z up)
		static void convertWorldToTerrainAxes(Alignment align, const Vector3& worldVec, Vector3* terrainVec);
		/// Utility method to convert axes from terrain space (xy terrain, z up) tp world space
		static void convertTerrainToWorldAxes(Alignment align, const Vector3& terrainVec, Vector3* worldVec);
	};
	/** Options class which just stores default options for the terrain.
	@remarks
		None of these options are stored with the terrain when saved. They are
		options that you can use to modify the behaviour of the terrain when it
		is loaded or created.
	@note
		You should construct a single instance of this class per application and
		do so before you start working with any other terrain classes.
	*/
	class TerrainGlobalOptions
	{

	public:
		/** The default size of 'skirts' used to hide terrain cracks
		(default 10)
		*/
		Ogre::Real getSkirtSize();
		/** method - the default size of 'skirts' used to hide terrain cracks
		(default 10)
		@remarks
			Changing this value only applies to Terrain instances loaded / reloaded afterwards.
		*/
		void setSkirtSize(Ogre::Real skirtSz);
		/// Get the shadow map light direction to use (world space)
		const Vector3& getLightMapDirection();
		/** Set the shadow map light direction to use (world space). */
		void setLightMapDirection(const Vector3& v);
		/// Get the composite map ambient light to use
		const ColourValue& getCompositeMapAmbient();
		/// Set the composite map ambient light to use
		void setCompositeMapAmbient(const ColourValue& c);
		/// Get the composite map iffuse light to use
		const ColourValue& getCompositeMapDiffuse();
		/// Set the composite map diffuse light to use
		void setCompositeMapDiffuse(const ColourValue& c);
		/// Get the distance at which to start using a composite map if present
		Ogre::Real getCompositeMapDistance();
		/// Set the distance at which to start using a composite map if present
		void setCompositeMapDistance(Ogre::Real c);

		/** Whether the terrain will be able to cast shadows (texture shadows
		only are supported, and you must be using depth shadow maps).
		*/
		bool getCastsDynamicShadows();

		/** Whether the terrain will be able to cast shadows (texture shadows
		only are supported, and you must be using depth shadow maps).
		This value can be set dynamically, and affects all existing terrains.
		It defaults to false.
		*/
		void setCastsDynamicShadows(bool s);

		/** Get the maximum screen pixel error that should be allowed when rendering. */
		Ogre::Real getMaxPixelError();

		/** Set the maximum screen pixel error that should  be allowed when rendering.
		@note
			This value can be varied dynamically and affects all existing terrains.
			It will be weighted by the LOD bias on viewports.
		*/
		void setMaxPixelError(Ogre::Real pixerr);

		/// Get the render queue group that this terrain will be rendered into
		unsigned int getRenderQueueGroup(void) { return mRenderQueueGroup; }
		/** Set the render queue group that terrains will be rendered into.
		@remarks This applies to newly created terrains, after which they will
			maintain their own queue group settings
		*/
		void setRenderQueueGroup(unsigned int grp);

		/// Get the visbility flags that terrains will be rendered with
		unsigned int getVisibilityFlags(void);
		/** Set the visbility flags that terrains will be rendered with
		@remarks This applies to newly created terrains, after which they will
		maintain their own settings
		*/
		void setVisibilityFlags(unsigned int flags);
		/** Set the default query flags for terrains.
		@remarks This applies to newly created terrains, after which they will
		maintain their own settings
		*/
		void  setQueryFlags(unsigned int flags);
		/** Get the default query flags for terrains.
		*/
		unsigned int getQueryFlags(void);

		/** As setQueryFlags, except the flags passed as parameters are appended to the existing flags on this object. */
		void addQueryFlags(unsigned int flags);

		/* As setQueryFlags, except the flags passed as parameters are removed from the existing flags on this object. */
		void removeQueryFlags(unsigned int flags);

		/** Returns whether or not to use an accurate calculation of camera distance
			from a terrain tile (ray / AABB intersection) or whether to use the
			simpler distance from the tile centre.
		*/
		bool getUseRayBoxDistanceCalculation();

		/** Sets whether to use an accurate ray / box intersection to determine
			distance from a terrain tile, or whether to use the simple distance
			from the tile centre.
			Using ray/box intersection will result in higher detail terrain because
			the LOD calculation is more conservative, assuming the 'worst case scenario'
			of a large height difference at the edge of a tile. This is guaranteed to give you at least
			the max pixel error or better, but will often give you more detail than
			you need. Not using the ray/box method is cheaper but will only use
			the max pixel error as a guide, the actual error will vary above and
			below that. The default is not to use the ray/box approach.
		*/
		void setUseRayBoxDistanceCalculation(bool rb);

		/** Get the default size of the blend maps for a new terrain.
		*/
		unsigned int getLayerBlendMapSize();

		/** Sets the default size of blend maps for a new terrain.
		This is the resolution of each blending layer for a new terrain.
		Once created, this information will be stored with the terrain.
		*/
		void setLayerBlendMapSize(unsigned int sz);

		/** Get the default world size for a layer 'splat' texture to cover.
		*/
		Ogre::Real getDefaultLayerTextureWorldSize();

		/** Set the default world size for a layer 'splat' texture to cover.
		*/
		void setDefaultLayerTextureWorldSize(Ogre::Real sz);

		/** Get the default size of the terrain global colour map for a new terrain.
		*/
		unsigned int getDefaultGlobalColourMapSize();

		/** Set the default size of the terrain global colour map for a new terrain.
		Once created, this information will be stored with the terrain.
		*/
		void setDefaultGlobalColourMapSize(unsigned int sz);


		/** Get the default size of the lightmaps for a new terrain.
		*/
		unsigned int getLightMapSize();
		/** Sets the default size of lightmaps for a new terrain.
		*/
		void setLightMapSize(unsigned int sz);

		/** Get the default size of the composite maps for a new terrain.
		*/
		unsigned int getCompositeMapSize();

		/** Sets the default size of composite maps for a new terrain.
		*/
		void setCompositeMapSize(unsigned int sz);

		/** Set the default resource group to use to load / save terrains.
		*/
		void setDefaultResourceGroup(const Ogre::String& grp);

		/** Get the default resource group to use to load / save terrains.
		*/
		const Ogre::String& getDefaultResourceGroup();
	};

	/** \addtogroup Optional Components
	*  @{
	*/
	/** \addtogroup Terrain
	*  Some details on the terrain component
	*  @{
	*/

	/** Helper class to assist you in managing multiple terrain instances
		that are connected to each other.
	@remarks
		This class makes it easy to specify the same options for a group of
		terrain instances and have them positioned relative to each other and
		associated via each other's neighbour connections. You can do all this
		manually but this class just makes things easier, so that you only
		have to specify most options once.
	@par
		Terrains are maintained in a grid of entries, and for simplicity
		the grid cells are indexed from 0 as a 'centre' slot, supporting both
		positive and negative values. so (0,0) is the centre slot, (1,0) is the
		slot to the right of the centre, (1,0) is the slot above the centre, (-2,1)
		is the slot two to the left of the centre and one up, etc. The maximum
		extent of each axis is -32768 to +32767, so in other words enough for
		over 4 billion entries. That should be enough for anyone!
	@par
		Note that this is not a 'paging' class as such. It's simply a way to make it easier to
		perform common tasks with multiple terrain instances, which you choose when
		to define, load and remove. Automatic paging is handled separately by the Paging
		component.
	*/
	class TerrainGroup
	{
	public:
		/** Constructor.
		@param sm The Ogre::SceneManager which will parent the terrain instances.
		@param align The alignment that all terrain instances will use
		@param terrainSize The size of each terrain down one edge in vertices (2^n+1)
		@param terrainWorldSize The world size of each terrain instance
		*/
		~TerrainGroup();

		/** Retrieve a shared structure which will provide the base settings for
			all terrains created via this group.
		@remarks
			All neighbouring terrains should have the same basic settings (particularly
			the size parameters) - to avoid having to set the terrain import information
			more than once, you can retrieve the standard settings for this group
			here and modify them to your needs. Once you've done that you can
			use the shortcut methods in this class to create new terrain instances
			using these base settings (plus any per-instance settings you might
			want to use).
		@note
			The structure returned from this method is intended for in-place modification,
			that's why it is not const and there is no equivalent 'set' method.
			You should not, however, change the alignment or any of the size parameters
			after you start constructing instances, since neighbouring terrains
			should have the same size & alignment.
		*/
		Terrain::ImportData& getDefaultImportSettings();

		/** Define the centre position of the grid of terrain.
		*/
		void setOrigin(const Vector3& pos);

		/** Retrieve the centre position of the grid of terrain.
		*/
		const Vector3& getOrigin() const;

		/** Retrieve the world size of each terrain instance (cannot be modified after construction).
		*/
		Ogre::Real getTerrainWorldSize() const;

		/** Set the naming convention for file names in this terrain group.
		@remarks
			You can more easily generate file names for saved / loaded terrain slots
			if you define a naming prefix. When you call saveAllTerrains(), all the
			terrain instances currently loaded will be saved to a file named
			&lt;prefix&gt;_&lt;index&gt;.&lt;extension&gt;, where &lt;index&gt; is
			given by packing the x and y coordinates of the entry into a 32-bit
			index (@see packIndex).
		*/
		void setFilenameConvention(const Ogre::String& prefix, const Ogre::String& extension);
		/// @see setFilenameConvention
		void setFilenamePrefix(const Ogre::String& prefix);
		/// @see setFilenameConvention
		void setFilenameExtension(const Ogre::String& extension);
		/// @see setFilenameConvention
		const Ogre::String& getFilenamePrefix() const;
		/// @see setFilenameConvention
		const Ogre::String& getFilenameExtension() const;

		/** Set the resource group in which files will be located. */
		void setResourceGroup(const Ogre::String& grp);
		/** Get the resource group in which files will be located. */
		const Ogre::String& getResourceGroup() const;
		/** Define a 'slot' in the terrain grid - in this case to be loaded from
			a generated file name.
		@remarks
			At this stage the terrain instance isn't actually present in the grid,
			you're merely expressing an intention for it to take its place there
			once it's loaded. The reason we do it like this is to support
			background preparation of this terrain instance.
		@note This method assumes that you want a file name to be generated from
			the naming convention that you have supplied (@see setFilenameConvention).
			If a file of that name isn't found during loading, then a flat terrain is
			created instead at height 0.
		@param x, y The coordinates of the terrain slot relative to the centre slot (signed).
		*/
		void defineTerrain @ defineTerrainAuto (long x, long y);

		/** Define a 'slot' in the terrain grid - in this case a flat terrain.
		@remarks
			At this stage the terrain instance isn't actually present in the grid,
			you're merely expressing an intention for it to take its place there
			once it's loaded. The reason we do it like this is to support
			background preparation of this terrain instance.
		@param x, y The coordinates of the terrain slot relative to the centre slot (signed).
		@param constantHeight The constant, uniform height that you want the terrain
			to start at
		*/
		void defineTerrain @ defineTerrainConstantHeight (long x, long y, float constantHeight);

		/** Define the content of a 'slot' in the terrain grid.
		@remarks
			At this stage the terrain instance isn't actually present in the grid,
			you're merely expressing an intention for it to take its place there
			once it's loaded. The reason we do it like this is to support
			background preparation of this terrain instance.
		@param x, y The coordinates of the terrain slot relative to the centre slot (signed).
		@param importData Import data - this data is copied during the
			call so  you may destroy your copy afterwards.
		*/
		void defineTerrain @ defineTerrainImportData (long x, long y, const Terrain::ImportData* importData);

		/** Define the content of a 'slot' in the terrain grid.
		@remarks
			At this stage the terrain instance isn't actually present in the grid,
			you're merely expressing an intention for it to take its place there
			once it's loaded. The reason we do it like this is to support
			background preparation of this terrain instance.
		@param x, y The coordinates of the terrain slot relative to the centre slot (signed).
		@param img Heightfield image - this data is copied during the call so  you may destroy your copy afterwards.
		@param layers Optional texture layers to use (if not supplied, default import
			data layers will be used) - this data is copied during the
			call so  you may destroy your copy afterwards.
		*/
		void defineTerrain @ defineTerrainHeightfield (long x, long y, const Ogre::Image* img, const Ogre::Terrain::LayerInstanceList* layers = 0);

		/** Define the content of a 'slot' in the terrain grid.
		@remarks
			At this stage the terrain instance isn't actually present in the grid,
			you're merely expressing an intention for it to take its place there
			once it's loaded. The reason we do it like this is to support
			background preparation of this terrain instance.
		@param x, y The coordinates of the terrain slot relative to the centre slot (signed).
		@param pFloat Heights array
		@param layers Optional texture layers to use (if not supplied, default import
			data layers will be used) - this data is copied during the
			call so  you may destroy your copy afterwards.
		*/
		//void defineTerrain (long x, long y, const float* pFloat, const Ogre::LayerInstanceList* layers = 0); -unsupported

		/** Define the content of a 'slot' in the terrain grid.
		@remarks
			At this stage the terrain instance isn't actually present in the grid,
			you're merely expressing an intention for it to take its place there
			once it's loaded. The reason we do it like this is to support
			background preparation of this terrain instance.
		@param x, y The coordinates of the terrain slot relative to the centre slot (signed).
		@param filename The name of a file which fully defines the terrain (as
			written by Terrain::save). Size settings from all files must agree.
		*/
		void defineTerrain @ defineTerrainFile (long x, long y, const Ogre::String& filename);


		/** Load any terrain instances that have been defined but not loaded yet.
		@param synchronous Whether we should force this to happen entirely in the
			primary thread (default false, operations are threaded if possible)
		*/
		void loadAllTerrains(bool synchronous = false);

		/** Load a specific terrain slot based on the definition that has already
			been supplied.
		@param x, y The coordinates of the terrain slot relative to the centre slot (signed).
		@param synchronous Whether we should force this to happen entirely in the
			primary thread (default false, operations are threaded if possible)
		*/
		void loadTerrain(long x, long y, bool synchronous = false);

		/** Unload a specific terrain slot.
		@remarks
			This destroys the Terrain instance but retains the slot definition (so
			it would be reloaded next time you call loadAllTerrains() if you did not
			remove it beforehand).
		@note
			While the definition of the terrain is kept, if you used import data
			to populate it, this will have been lost so repeat loading cannot occur.
			The only way to support repeat loading is via the 'filename' option of
			defineTerrain instead.
		@param x, y The coordinates of the terrain slot relative to the centre slot (signed).
		*/
		void unloadTerrain(long x, long y);

		/** Remove a specific terrain slot.
		@remarks
			This destroys any Terrain instance at this position and also removes the
			definition, so it essentially no longer exists.
		@param x, y The coordinates of the terrain slot relative to the centre slot (signed).
		*/
		void removeTerrain(long x, long y);

		/** Remove all terrain instances.
		*/
		void removeAllTerrains();

		/** Save all terrain instances using the assigned file names, or
			via the filename convention.
		@see setFilenameConvention
		@see setResourceGroup
		@param onlyIfModified If true, only terrains that have been modified since load(),
			or since the last save(), will be saved. You want to set this to true if
			you loaded the terrain from these same files, but false if you
			defined them using some other input data since the files wouldn't exist.
		@param replaceManualFilenames If true, replaces any manually defined filenames
			in the TerrainSlotDefinition with the generated names from the convention.
			This is recommended since it makes everything more consistent, although
			you might want to use manual filenames in the original definition to import
			previously separate data.
		*/
		void saveAllTerrains(bool onlyIfModified, bool replaceManualFilenames = true);

		/** Definition of how to populate a 'slot' in the terrain group.
		*/
		struct TerrainSlotDefinition
		{
			/// Filename, if this is to be loaded from a file
			Ogre::String filename;
			/// Import data, if this is to be defined based on importing
			Terrain::ImportData* importData;

			TerrainSlotDefinition();
			~TerrainSlotDefinition();

			/// Set to use import data
			void useImportData();
			/// Set to use file name
			void useFilename();
			/// Destroy temp import resources
			void freeImportData();
		};

		/** Slot for a terrain instance, together with its definition. */
		struct TerrainSlot
		{
			/// The coordinates of the terrain slot relative to the centre slot (signed).
			long x, y;
			/// Definition used to load the terrain
			TerrainSlotDefinition def;
			/// Actual terrain instance
			Terrain* instance;

			TerrainSlot(long _x, long _y);
			~TerrainSlot();
			void freeInstance();
		};

		/** Get the definition of a slot in the terrain.
		@remarks
			Definitions exist before the actual instances to allow background loading.
		@param x, y The coordinates of the terrain slot relative to the centre slot (signed).
		@returns The definition, or null if nothing is in this slot. While this return value is
			not const, you should be careful about modifying it; it will have no effect unless you load
			the terrain afterwards, and can cause a race condition if you modify it while a background
			load is in progress.
		*/
		TerrainSlotDefinition* getTerrainDefinition(long x, long y) const;

		/** Get the terrain instance at a given slot, if loaded.
		@param x, y The coordinates of the terrain slot relative to the centre slot (signed).
		@returns The terrain, or null if no terrain is loaded in this slot (call getTerrainDefinition if
			you want to access the definition before it is loaded).
		*/
		Terrain* getTerrain(long x, long y) const;

		/** Free as many resources as possible for optimal run-time memory use for all
			terrain tiles.
		@see Terrain::freeTemporaryResources
		*/
		void freeTemporaryResources();

		/** Trigger the update process for all terrain instances.
		@see Terrain::update
		*/
		void update(bool synchronous = false);

		/** Performs an update on all terrain geometry.
		@see Terrain::updateGeometry
		*/
		void updateGeometry();

		/** Updates derived data for all terrains (LOD, lighting) to reflect changed height data.
		@see Terrain::updateDerivedData
		*/
		void updateDerivedData(bool synchronous = false, unsigned int typeMask = 0xFF);

		/** Result from a terrain ray intersection with the terrain group.
		*/
		struct RayResult
		{
			/// Whether an intersection occurred
			bool hit;
			/// Which terrain instance was hit, if any
			Terrain* terrain;
			/// Position at which the intersection occurred
			Vector3 position;

			RayResult(bool _hit, Terrain* _terrain, const Vector3& _pos);
		};

		/** Get the height data for a given world position (projecting the point
		down on to the terrain underneath).
		@param x, y,z Position in world space. Positions will be clamped to the edge
		of the terrain
		@param ppTerrain Pointer to a pointer to a terrain which will be completed
			with the terrain that was found to resolve this query, or null if none were
		*/
		float getHeightAtWorldPosition(Ogre::Real x, Ogre::Real y, Ogre::Real z, Terrain** ppTerrain = 0);

		/** Get the height data for a given world position (projecting the point
		down on to the terrain).
		@param pos Position in world space. Positions will be clamped to the edge
		of the terrain
		@param ppTerrain Pointer to a pointer to a terrain which will be completed
		with the terrain that was found to resolve this query, or null if none were
		*/
		float getHeightAtWorldPosition(const Vector3& pos, Terrain** ppTerrain = 0);

		/** Test for intersection of a given ray with any terrain in the group. If the ray hits
		 a terrain, the point of intersection and terrain instance is returned.
		 @param ray The ray to test for intersection
		 @param distanceLimit The distance from the ray origin at which we will stop looking,
			0 indicates no limit
		 @return A result structure which contains whether the ray hit a terrain and if so, where.
		 @remarks This can be called from any thread as long as no parallel write to
		 the terrain data occurs.
		 */
		RayResult rayIntersects(const Ogre::Ray& ray, Ogre::Real distanceLimit = 0) const;

		/** Test intersection of a box with the terrain.
		@remarks
			Tests an AABB for overlap with a terrain bounding box. Note that this does not mean that the box
			touches the terrain itself, just the bounding box for the terrain. You can use this to get region
			results for further testing or use (e.g. painting areas).
		@param box The AABB you want to test in world units
		@param resultList Pointer to a list of terrain pointers which will be updated to include just
			the terrains that overlap
		*/
		void boxIntersects(const Ogre::AxisAlignedBox& box, Ogre::TerrainGroup::TerrainList* resultList) const;
		/** Test intersection of a sphere with the terrain.
		@remarks
			Tests a sphere for overlap with a terrain bounding box. Note that this does not mean that the sphere
			touches the terrain itself, just the bounding box for the terrain. You can use this to get region
			results for further testing or use (e.g. painting areas).
		@param sphere The sphere you want to test in world units
		@param resultList Pointer to a list of terrain pointers which will be updated to include just
			the terrains that overlap
		*/
		void sphereIntersects(const Ogre::Sphere& sphere, Ogre::TerrainGroup::TerrainList* resultList) const;

		/** Convert a world position to terrain slot coordinates.
		@param pos The world position
		@param x,y Pointers to the coordinates to be completed.
		*/
		void convertWorldPositionToTerrainSlot(const Vector3& pos, long *x, long *y) const;

		/** Convert a slot location to a world position at the centre
		@param x,y The slot coordinates
		@param pos Pointer to the world position to be completed
		*/
		void convertTerrainSlotToWorldPosition(long x, long y, Vector3* pos) const;

		/** Calls Terrain::isDerivedDataUpdateInProgress on each loaded instance and returns true
			if any of them are undergoing a derived update.
		*/
		bool isDerivedDataUpdateInProgress() const;

		/// Convert coordinates to a packed integer index
		unsigned int packIndex(long x, long y) const;

		/// Convert a packed integer index to coordinates
		void unpackIndex(unsigned int key, long *x, long *y);

		/// Generate a file name based on the current naming convention
		Ogre::String generateFilename(long x, long y) const;

		/** Save the group data only in native form to a file.
		*/
		void saveGroupDefinition(const Ogre::String& filename);
		/** Save the group data only in native form to a serializing stream.
		*/
		void loadGroupDefinition(const Ogre::String& filename);
	};


	/** @} */
	/** @} */

};
